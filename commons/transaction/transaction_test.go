package transaction

import (
	"testing"

	"github.com/shopspring/decimal"
	"github.com/stretchr/testify/assert"
)

func TestBalance_IsEmpty(t *testing.T) {
	tests := []struct {
		name string
		rate Rate
		want bool
	}{
		{
			name: "Empty rate",
			rate: Rate{},
			want: true,
		},
		{
			name: "Non-empty rate",
			rate: Rate{
				From:       "BRL",
				To:         "USD",
				Value:      decimal.NewFromInt(100),
				ExternalID: "00000000-0000-0000-0000-000000000000",
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.rate.IsEmpty()
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestFromTo_SplitAlias(t *testing.T) {
	tests := []struct {
		name         string
		accountAlias string
		want         string
	}{
		{
			name:         "Alias without index",
			accountAlias: "@person1",
			want:         "@person1",
		},
		{
			name:         "Alias with index",
			accountAlias: "1#@person1",
			want:         "@person1",
		},
		{
			name:         "Alias with index and balance key",
			accountAlias: "1#@person1#savings",
			want:         "@person1",
		},
		{
			name:         "Alias with index and empty balance key",
			accountAlias: "0#@external#",
			want:         "@external",
		},
		{
			name:         "Alias with index and default balance key",
			accountAlias: "2#@account#default",
			want:         "@account",
		},
		{
			name:         "Complex alias with index and balance key",
			accountAlias: "5#@external/BRL#checking",
			want:         "@external/BRL",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ft := FromTo{
				AccountAlias: tt.accountAlias,
			}
			got := ft.SplitAlias()
			assert.Equal(t, tt.want, got)
		})
	}
}

func TestFromTo_ConcatAlias(t *testing.T) {
	tests := []struct {
		name         string
		accountAlias string
		balanceKey   string
		index        int
		want         string
	}{
		{
			name:         "Concat index with alias and balance key",
			accountAlias: "@person1",
			balanceKey:   "savings",
			index:        1,
			want:         "1#@person1#savings",
		},
		{
			name:         "Concat index with alias and empty balance key",
			accountAlias: "@person2",
			balanceKey:   "",
			index:        0,
			want:         "0#@person2#",
		},
		{
			name:         "Concat index with alias and default balance key",
			accountAlias: "@person3",
			balanceKey:   "default",
			index:        2,
			want:         "2#@person3#default",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ft := FromTo{
				AccountAlias: tt.accountAlias,
				BalanceKey:   tt.balanceKey,
			}
			got := ft.ConcatAlias(tt.index)
			assert.Equal(t, tt.want, got)
		})
	}
}

// TestFromTo_ConcatSplitAlias_Compatibility verifies that SplitAlias can correctly parse strings generated by ConcatAlias
func TestFromTo_ConcatSplitAlias_Compatibility(t *testing.T) {
	tests := []struct {
		name         string
		accountAlias string
		balanceKey   string
		index        int
	}{
		{
			name:         "Standard alias with balance key",
			accountAlias: "@person1",
			balanceKey:   "savings",
			index:        1,
		},
		{
			name:         "External alias with empty balance key",
			accountAlias: "@external/BRL",
			balanceKey:   "",
			index:        0,
		},
		{
			name:         "Complex alias with default balance key",
			accountAlias: "@company/accounts/primary",
			balanceKey:   "default",
			index:        5,
		},
		{
			name:         "Simple alias with special balance key",
			accountAlias: "@test",
			balanceKey:   "checking-account",
			index:        999,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ft := FromTo{
				AccountAlias: tt.accountAlias,
				BalanceKey:   tt.balanceKey,
			}

			// Generate concatenated string using ConcatAlias
			concatenated := ft.ConcatAlias(tt.index)

			// Create new FromTo with the concatenated string as AccountAlias
			ftWithConcatenated := FromTo{
				AccountAlias: concatenated,
			}

			// Extract alias using SplitAlias
			extractedAlias := ftWithConcatenated.SplitAlias()

			// Verify that extracted alias matches the original
			assert.Equal(t, tt.accountAlias, extractedAlias,
				"SplitAlias should extract the original alias from ConcatAlias output")
		})
	}
}

func TestFromTo_ConcatSplitAlias_AliasContainsHash(t *testing.T) {
	ft := FromTo{
		AccountAlias: "@person#vip",
		BalanceKey:   "savings",
	}

	concatenated := ft.ConcatAlias(1)
	ftWithConcatenated := FromTo{AccountAlias: concatenated}
	extractedAlias := ftWithConcatenated.SplitAlias()

	// Current behavior (documented): alias gets truncated at '#' due to ambiguous delimiter usage.
	// This test documents the ambiguity; consider changing serialization or adding escaping.
	assert.Equal(t, "@person", extractedAlias)
}

func TestFromTo_ConcatSplitAlias_BalanceKeyContainsHash(t *testing.T) {
	ft := FromTo{
		AccountAlias: "@person",
		BalanceKey:   "sav#ings",
	}

	concatenated := ft.ConcatAlias(2)
	ftWithConcatenated := FromTo{AccountAlias: concatenated}
	extractedAlias := ftWithConcatenated.SplitAlias()

	// Alias should still be extracted correctly regardless of balanceKey content
	assert.Equal(t, ft.AccountAlias, extractedAlias)
}

func TestTransaction_IsEmpty(t *testing.T) {
	tests := []struct {
		name        string
		transaction Transaction
		want        bool
	}{
		{
			name: "Empty transaction",
			transaction: Transaction{
				Send: Send{
					Asset: "",
					Value: decimal.NewFromInt(0),
				},
			},
			want: true,
		},
		{
			name: "Non-empty transaction with asset",
			transaction: Transaction{
				Send: Send{
					Asset: "BRL",
					Value: decimal.NewFromInt(0),
				},
			},
			want: false,
		},
		{
			name: "Non-empty transaction with value",
			transaction: Transaction{
				Send: Send{
					Asset: "",
					Value: decimal.NewFromInt(100),
				},
			},
			want: false,
		},
		{
			name: "Complete non-empty transaction",
			transaction: Transaction{
				Send: Send{
					Asset: "BRL",
					Value: decimal.NewFromInt(100),
				},
			},
			want: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := tt.transaction.IsEmpty()
			assert.Equal(t, tt.want, got)
		})
	}
}
